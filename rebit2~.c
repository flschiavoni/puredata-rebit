/* Plugin structure generated by Schiavoni Pure Data external Generator */
#include "m_pd.h"
#include <math.h>
// ---------------------------------------------------
// Conversion function
// ---------------------------------------------------
int32_t rebit_float2int(float f){
if (f >= 1.0) 
    return 2147483647; 
else if (f <= -1.0) 
    return -2147483648; 
else 
    return floor(f * 2147483648.0f);
}


// ---------------------------------------------------
// Conversion function
// ---------------------------------------------------
float rebit_int2float(int32_t i){
   return i / 2147483648.0f;
}

// ---------------------------------------------------
// Class definition
// ---------------------------------------------------
static t_class *rebit2_class;

// ---------------------------------------------------
// Data structure definition
// ---------------------------------------------------
typedef struct _rebit2 {
   t_object x_obj;
   t_inlet * x_inlet_dsp_0;
   t_inlet * x_inlet_dsp_1;

   t_outlet * x_outlet_dsp_0;

} t_rebit2;

// ---------------------------------------------------
// Functions signature
// ---------------------------------------------------
void * rebit2_new(void);// Constructor
void rebit2_destroy(t_rebit2 *x); //Destructor
static t_int * rebit2_perform(t_int *w); //Perform function
static void rebit2_dsp(t_rebit2 *x, t_signal **sp); //DSP function

// ---------------------------------------------------
// Perform
// ---------------------------------------------------
static t_int * rebit2_perform(t_int *w){
//   t_rebit2 *x = (t_rebit2 *)(w[1]);
   int n = (int)(w[2]);
   t_float *in1 = (t_float *)(w[3]);
   t_float *in2 = (t_float *)(w[4]);
   t_float *out1 = (t_float *)(w[5]);

   int i = 0;
   int j = 0;
   int32_t sample = 0;
	for(i = 0 ; i < n ; i++){
      sample = rebit_float2int(in1[i]); // convert sample from float 32 to int32

      int bit = ((int)in2[i] > 32)?32:(int)in2[i]; // bit value adjustment
      bit = (bit < 0)?0:bit;                       // bit value adjustment

      for(j = 0 ; j < 32 - bit ; j++){
         sample >>= 1; //Down size
      }
      for(j = 0 ; j < 32 - bit ; j++){
         sample <<= 1; // Up size to scale back
      }
      out1[i] = rebit_int2float(sample); // convert it back to float 32
	}

    return (w + 6); // proximo bloco
}

// ---------------------------------------------------
// DSP Function
// ---------------------------------------------------
static void rebit2_dsp(t_rebit2 *x, t_signal **sp){
   dsp_add(rebit2_perform, 5, x, sp[0]->s_n, sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec);
}

// ---------------------------------------------------
// Constructor of the class
// ---------------------------------------------------
void * rebit2_new(void){
   t_rebit2 *x = (t_rebit2 *) pd_new(rebit2_class);

   x->x_inlet_dsp_0 = inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
   x->x_inlet_dsp_1 = inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);

   x->x_outlet_dsp_0 = outlet_new(&x->x_obj, &s_signal);

   return (void *) x;
}

// ---------------------------------------------------
// Destroy the class
// ---------------------------------------------------
void rebit2_destroy(t_rebit2 *x) {
   post("You say good bye and I say hello");
   inlet_free(x->x_inlet_dsp_0);
   inlet_free(x->x_inlet_dsp_1);

   outlet_free(x->x_outlet_dsp_0);

}

// ---------------------------------------------------
// Setup
// ---------------------------------------------------
void rebit2_tilde_setup(void) {
   rebit2_class = class_new(gensym("rebit2~"),
      (t_newmethod) rebit2_new, // Constructor
      (t_method) rebit2_destroy, // Destructor
      sizeof (t_rebit2),
      CLASS_NOINLET,
      0);//Must always ends with a zero

   class_addmethod(rebit2_class, (t_method) rebit2_dsp, gensym("dsp"), 0);
}
// EOF---------------------------------------------------
